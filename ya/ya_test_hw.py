# -*- coding: utf-8 -*-

# Дан словарь:
# Сколько параметров, каких типов и значений передадутся при вызове функций:

# func1(d)
# func2(*d)
# func3(**d)

"""
func1(d) - передаст весь dict целиком, как один параметр {1: 2, 3: 4}
func2(*d) - передаст tuple со значениями 1 и 3, как один параметр (1, 3)
func3(**d) - будет передавать словарь целиком, как один параметр {1: 2, 3: 4}.
"""


# Значения какого типа будет содержать переменная y в следующем коде:

# x = {1: 2, 3: 4}
# y = x.items()

"""
В третьей версии python Y будет содержать экземпляр dict_items, внутри которого
список из кортежей, в Python2 будет тип list, состоящий из кортежей.
"""


# Что напечатает данная программа:

# x = [[]]*3
# x[0].append('a')
# x[1].append('b')
# x[2].append('c')
# x[0] = ['d']
# print x

"""
[['d'], ['a', 'b', 'c'], ['a', 'b', 'c']]

Когда создается новый список умножением, то интерпретатор копирует ссылку на указанный элемент.
Таким образом мы получаем три элемента списка, ссылающиеся на один и тот же список (внутренний).
И когда происходит добавление (x[0].append('a'), x[1].append('b'), x[2].append('c')) значений в элементы списка,
то значения добавляются в одит и тот же элемент, т.к. все три значения списка ссылаются на него.
В случае с изменением значения (x[0]=['d']) происходит изменение ссылки на другой список, с другим идентификатором.
"""


# Напишите декоратор, который печатает результат выполнения функции.

"""
def print_func_result(func):
	def executer(*func_args, **func_kwargs):
		print(func(*func_args, **func_kwargs))

	return executer
"""


# Напишите генератор, который производит чётные натуральные числа.

"""
def gen_even_numb():
	a = 0
	while True:
		a += 2
		yield a

# применение:

gen = gen_even_numb()

for i in range(10):
	print(next(gen))
"""


# Что напечатает следующая программа? Почему?

funcs = []
for i in range(5):
    def f(ind):
      print (ind)
    funcs.append(f)

for ind, f in enumerate(funcs):
  f(ind)

"""
4
4
4
4
4

Все функции массива funcs напечатают 4, т.к. в теле функции у всех ссылка на переменную i,
которая к моменту запуска функций имеет значение 4 (в результате работы цикла+range)
"""


# Напишите функцию, которая принимает на вход последовательность строк,
# отбрасывает из списка пустые строки в конце и начале,
# а в других местах списка идущие подряд несколько пустых строк заменяет на одну.
# Например: ["", "abc", "123", "", "x", "", "", "y", "", "" ] должно превратиться в: ["abc", "123", "", "x", "", "y"].
# Оформите её в виде модуля.
# Сделайте так, чтоб функция могла работать с потенциально бесконечными генераторами
# (и была бы сама генератором, соответственно).

from clean_space import space_cleaning

l = ["", "", "abc", "123", "", "x", "", "", "", "y", "", "", ""]
t = tuple(l)
g = (x for x in l)

# space clearing for the list

print(space_cleaning(l))
print(space_cleaning(t))

# space clearing for the generator

for i in space_cleaning(g):
	print(i)
